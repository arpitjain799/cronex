#!/usr/bin/env python
# -*- coding: utf-8 -*-
import contextlib
import sys
import traceback
import unittest

# TODO: Better set differences.
# TODO: Context manager that set default message for failing tests.
# TODO: Show default sequence diff message in addition to the user-specified message.


class Error(Exception):
    """
    Module-specific base exception class.
    """


class NonFatalAssertionError(AssertionError, Error):
    """
    Exception raised when an assertion in a method called with `fatal=False`
    fails.
    """


class FatalErrorSignalException(Error):
    """
    Exception raised when an assertion in a method called with `fatal=True`
    fails or the method raised an exception with an unrecognized type (by
    default, anything other than "AssertionError").
    """


class TestFailure(AssertionError, Error):
    """
    Exception raised when a test method fails with multiple exceptions with
    differing types.
    """


class MultipleCauseTestFailure(TestFailure):
    """
    Exception raised when a test method fails with multiple exceptions with
    differing types.
    """


class NewAssertionsMixin(object):
    """
    This mix-in class implements new assertion methods.
    """

    def assertReturns(self, expected, function, *args, **kwargs):
        """
        Assert that a function call returns a particular value.
        """
        # TODO: does not work when expected / result are tuples
        try:
            result = function(*args, **kwargs)
            unittest.TestCase.assertEqual(self, expected, result)
            return result
        except Exception as e:
            if hasattr(e, "args"):
                signature = call_signature(function, *args, **kwargs)
                if e.args:
                    e_args_list = list(e.args)
                    e_args_list[0] = "%s: %s" % (signature, e_args_list[0])
                    e.args = tuple(e_args_list)
                else:
                    e.args = (signature, )
            raise


class ImprovedErrorsMixin(object):
    """
    This mix-in class improves the error messages generated by failing unit
    tests.
    """

    def assertRaises(self, expected_exception, *args, **kwargs):
        """
        The arguments used to call a function are added to the AssertionError
        generated by this function.
        """
        parent = super(ImprovedErrorsMixin, self)
        try:
            return parent.assertRaises(expected_exception, *args, **kwargs)
        except AssertionError as e:
            signature = call_signature(args[0], *args[1:], **kwargs)
            if e.args:
                e_args_list = list(e.args)
                e_args_list[0] = "%s: %s" % (signature, e_args_list[0])
                e.args = tuple(e_args_list)
            else:
                e.args = (signature, )
            raise

    def assertSetEqual(self, set1, set2, msg=None):
        """
        When both sets are relative short, use unittest.assertSequenceEqual so
        all elements of both sets are shown.
        """
        if len(set1) > 25 or len(set2) > 25:
            return unittest.TestCase.assertSetEqual(self, set1, set2, msg=msg)

        set1 = sorted(set1)
        set2 = sorted(set2)
        return unittest.TestCase.assertSequenceEqual(self, set1, set2, msg=msg)


class NonFatalAssertionsMixin(object):
    """
    This mix-in modifies all assertion methods to accept an extra argument, the
    boolean keyword "fatal". This argument determines whether or not an assertion
    failure causes the test to fail immediately or only once the test method is
    finished. If "fatal" is False, the return value of an assertion method is a
    boolean indicating whether assertion succeeded. If "fatal" is True, the
    return value of this function is the value returned by the underlying
    assertion method.
    """
    assertion_errors = dict()
    exceptions_fatal_by_default = True
    failure_exception = unittest.TestCase.failureException
    non_fatal_assertion_error = NonFatalAssertionError

    def _trace(self, tb=None):
        """
        Return a textual stack trace that removes frames that are irrelevant to
        the user's test suite.

        Returns: The stack trace as a string that may have embedded newlines.
        """
        # TODO: figure out when to use sys.exc_info.
        if tb is None:
            stack = traceback.extract_stack()
            del stack[-2:]
            del stack[:self._ignored_frames_from_head]
        else:
            stack = traceback.extract_tb(tb)

        return "".join(traceback.format_list(stack)).rstrip("\n")

    def __getattribute__(self, name):
        """
        Intercept requests for callable attributes that start with "assert" or
        "test" and return wrapped versions of the methods.
        """
        attribute = object.__getattribute__(self, name)

        if not name.startswith(("assert", "test")) or not callable(attribute):
            return attribute

        # Return a wrapper that implements support for the "fatal" keyword.
        elif name.startswith("assert"):
            if not hasattr(TestCase, name):
                return attribute

            def method(*args, **kwargs):
                fatal = kwargs.pop("fatal", self.exceptions_fatal_by_default)
                errors = self.assertion_errors[self]

                try:
                    return attribute(*args, **kwargs)
                except AssertionError as e:
                    exception_type = type(e)
                    if not fatal and isinstance(e, self.failure_exception):
                        exception_type = self.non_fatal_assertion_error

                    errors.append((exception_type, e, self._trace()))
                    if fatal:
                        raise FatalErrorSignalException()

        # The wrapped version of the test method delays reporting non-fatal
        # errors until there is a fatal assertion failure or the original test
        # method has finished running.
        elif name.startswith("test"):
            def method(*args, **kwargs):
                self._ignored_frames_from_head = len(traceback.extract_stack())
                errors = self.assertion_errors.setdefault(self, list())

                try:
                    result = attribute(*args, **kwargs)
                except FatalErrorSignalException:
                    pass
                except AssertionError:
                    error_type, error, tb = sys.exc_info()
                    errors.append((error_type, error, self._trace(tb)))
                finally:
                    del self.assertion_errors[self]

                if not errors:
                    return result

                if len(errors) == 1:
                    error_type, error, stack = errors[0]
                    raise error_type("%s\n%s" % (error, stack))

                lines = ["%d exceptions raised during test;" % (len(errors), )]
                error_types = set([t for t, _, _ in errors])

                for n, (error_type, error, stack) in enumerate(errors, 1):
                    if n > 1:
                        lines.append("--")

                    lines.append("Traceback #%d:" % (n, ))
                    lines.extend(stack.splitlines())
                    lines.append("%s: %s" % (error_type.__name__, error))

                raised_error_type = TestFailure
                if error_types:
                    raised_error_type = MultipleCauseTestFailure

                raise raised_error_type("\n  ".join(lines))

        method.__doc__ = attribute.__doc__
        method.__name__ = attribute.__name__
        return method

    @contextlib.contextmanager
    def non_fatal_exception(self):
        """
        Context manager for deferring exception reporting until a unit test has
        concluded.
        """
        errors = self.assertion_errors[self]

        try:
            yield
        except Exception:
            error_type, error, tb = sys.exc_info()
            errors.append((error_type, error, self._trace(tb)))


class TestCase(ImprovedErrorsMixin, NonFatalAssertionsMixin,
  NewAssertionsMixin, unittest.TestCase):
    """
    Class derived from the standard library's unittest.TestCase with all
    supported mixins.
    """

    @classmethod
    def defaults(cls, fatal=True):
        """
        Create a TestCase class with a certain set of default values for
        various mixin properties.

        Arguments:
        - fatal (boolean): This value controls whether or not assertion method
          failures are fatal by default.
        """
        class TestCase(cls):
            exceptions_fatal_by_default = fatal
        return TestCase


def call_signature(function, *args, **kwargs):
    parts = [repr(arg) for arg in args]
    if kwargs:
        parts.extend(("%s=%r" % k_v for k_v in kwargs.items()))
    return "%s(%s)" % (function.__name__, ", ".join(parts))


def main(*args, **kwargs):
    """
    Thin wrapper for unittest.main so code that uses this module can start the
    test suite without importing the standard library's unittest module.
    """
    unittest.main(*args, **kwargs)


main.__doc__ = unittest.main.__doc__
